#!/usr/bin/env ruby

require 'rubygems'
require 'commander/import'
require 'ruby-progressbar'
require_relative '../lib/experiment'
require 'rugged'
require 'thwait'
require "colorize"
require 'tmpdir'
require 'bigdecimal'
require 'csv'

def to_numeric(anything)
  num = BigDecimal.new(anything.to_s)
  if num.frac == 0
    num.to_i
  else
    num.to_f
  end
end

program :name, 'experiment'
program :version, Experiment::VERSION
program :description, 'A tool for running concurrent multi-configuration experiments'

def values(spec)
	if spec =~ /^set\((.*)\)$/
		return CSV.parse_line($1).map { |v| v.strip }
	elsif spec =~ /^range\((.*)\)$/
		args = $1.split(/\s*,\s*/).map { |v| to_numeric(v.strip) }
		values = []
		i = args[0]
		while i < args[1]
			values.push i
			i += (args.length > 2 ? args[2] : 1)
		end
		return values
	end
end

def replace(vname, template, parameters)
	r = Proc.new { |x|
		x = x.gsub(/(?<!\\)\$(\w+)/) {|m| parameters.include?($1) ? parameters[$1] : $&}
		x = x.gsub(/(?<!\\)\${(.*?)}/) {|m| parameters.include?($1) ? parameters[$1] : $&}
		x
	}

	version = {}
	template.each do |k, v|
		if k == "vary"
			next
		end
		if v.is_a? String
			version[k] = r.call(v)
		elsif v.is_a? Array
			version[k] = v.map { |x| r.call(x) }
		else
			version[k] = v
		end
	end
	return [r.call(vname), version]
end

command :run do |c|
	c.syntax = 'experiment run'
	c.summary = 'Run the experiments outlined in experiment.json'
	c.option '-r', '--repository FILE', String, 'override location of source code'
	c.option '-o', '--output DIR', String, 'override location of experiment output'
	c.action do |args, options|
		begin
			config = Experiment::read_config Dir.pwd
		rescue Exception => er
			raise ArgumentError.new er.message
		end

		if options.output
			if File.exist? options.output
				raise ArgumentError.new "Output directory #{options.output} already exists; exiting."
			end
			FileUtils.mkdir_p options.output
			Dir.chdir options.output
		end

		repository = (options.repository ||
					  config["repository"].gsub("~", Dir.home))
		repo = Rugged::Repository.new(repository)

		# Expand version templates
		all_versions = {}
		config["versions"].each do |vname, template|
			versions = []
			if not template.include? "vary"
				versions.push [vname, template]
			else
				fields = []
				vals = []
				template["vary"].each do |field, spec|
					fields.push field
					vals.push values(spec)
				end
				vals = [nil].product *vals
				vals.each do |parameters|
					parameters = Hash[fields.zip parameters[1..-1]]
					versions.push replace(vname, template, parameters)
				end
			end

			versions.each do |version|
				# TODO: check for overwrites
				all_versions[version[0]] = version[1]
			end
		end

		# Create list of versions, organized by build
		build_versions = Hash.new { |hash,key| hash[key] = {} }
		all_versions.each do |vname, version|
			app = Experiment::Application.new(:wd => Dir.pwd + "/" + vname,
								      :config => config,
								      :version => version,
								      :repo => repo)
			build_versions[app.build][vname] = app
		end

		# Build each distinct build, then use it to initialize the relevant
		# versions.
		bad = []
		build_versions.each do |build, versions|
			begin
				Dir.mktmpdir do |build_dir|
					build.build(build_dir)
					versions.each do |vname, a|
						a.copy_build(vname, build_dir)
					end
				end
			rescue Exception => e
				STDERR.puts sprintf(" -> %s failed!", build).red
				bad.push build
			end
		end

		if bad.length == build_versions.length
			STDERR.puts sprintf("==> ERROR: no buildable version found!").red.bold
			exit 1
		end

		ops = []
		for n in 1..config["iterations"] do
			iops = []
			build_versions.each do |build, versions|
				if bad.include? build
					if n == 1
						versions.each do |vname, a|
							STDERR.puts sprintf("==> WARNING: ignoring version with failed build: %s", vname).yellow.bold
						end
					end
					next
				end
				versions.each do |vname, a|
					iops << [vname, a, n]
				end
			end

			# to improve time estimation, run versions in random
			# order while ensuring all versions within an iteration
			# are run before the next iteration is started.
			iops.shuffle!
			ops << iops
		end
		ops.flatten! 1

		running = 0
		threads = []
		twait = nil
		puts "==> Versions ready, starting experiment".bold
		p = ProgressBar.create :total => ops.count, :format => "Progress: [%B] %p%% %E "

		Signal.trap("TERM") do
			Experiment.stop
		end
		Signal.trap("INT") do
			Experiment.stop
		end

		for op in ops do
			break if Experiment.stopped

			vname, a, n = *op
			if running >= config["parallelism"]
				begin
					t = twait.next_wait
				rescue
					# woken up by a signal
					break
				end
				p.increment
				threads.delete t
			end

			break if Experiment.stopped

			threads << Thread.new(vname, a, n) do |vname, a, n|
				begin
					a.run(n)
				rescue Exception => er
					STDERR.puts sprintf("\n -> Failed to run version %s: %s", vname, er).red.bold
				end
			end
			twait = ThreadsWait.new *threads
			running += 1
		end
		twait.all_waits { p.increment }
		puts "==> Stopped experimenting after user interrupt".bold if Experiment.stopped
	end
end

command :init do |c|
	c.syntax = 'experiment init'
	c.summary = 'Create a fresh experiment.json'
	#c.description = ''
	#c.example 'description', 'command example'
	#c.option '--some-switch', 'Some switch that does something'
	c.action do |args, options|
		file = "experiment.json"
		description = ask 'Describe your experiment: '
		repo = ask 'Where is the source repository located: '
		checkout = ask 'What commit do you want to base the experiment on? '
		iterations = ask 'Number of iterations for each version: '
		parallelism = ask 'Number of parallel executions: '
		versions = ask_for_array 'List the versions you wish to create: '
		begin
			File.open(file, 'w') do |f|
				f.write <<-"..."
{
	"experiment": "#{description}",
	"repository": "#{repo}",
	"checkout": "#{checkout}",
	"iterations": #{iterations},
	"parallelism": #{parallelism},
	"build": "make",
	"arguments": [ ],
	"versions": {
				...
				versions.each do |version|
					f.write <<-"..."
		"#{version}": {
		}
					...
				end
				f.write <<-"..."
	}
}
				...
			end
		end
		say "experiment.json created, now configure your versions and the execution command"
	end
end

default_command :run
